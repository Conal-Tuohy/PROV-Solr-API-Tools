<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:dummy="dummy">

	<xsl:output method="text" media-type='text/plain"'/>
<!--
	<xsl:output method="text" media-type='application/ld+json;profile="http://iiif.io/api/presentation/3/context.json"'/>
-->

	<xsl:param name="base-uri" select=" 'https://api.prov.vic.gov.au/search/select?' "/>
	<!-- The request parameters extracted by Solr from the query URL -->
	<xsl:variable name="parameters" select="/response/lst[@name='responseHeader']/lst[@name='params']/*"/>
	<!-- 
	NB the dummy:str element defined here is a placeholder for a str[@name='start'] element which may not exist, since the 'start'
	parameter in a Solr request query URL is optional. We define it here so that we can include it along with the list of parameters which 
	WERE requested, and sort it by @name in the appropriate position in the parameter list, which should be sorted alphabetically by @name
	-->
	<xsl:variable name="start-parameter" select="document('')/*/dummy:str"/>
	<dummy:str name="start">A dummy parameter used as a placeholder for a Solr str element, when generating a "next page" URL</dummy:str>
	<!-- total number of documents in this and all previous and subsequent pages -->
	<xsl:variable name="documents-in-all-pages" select="/response/result[@name='response']/@numFound"/>
	<!-- number of documents in the current page of the Collection -->
	<xsl:variable name="documents-in-current-page" select="count(/response/result[@name='response']/doc)"/>
	<!-- the number of documents in previous pages (starts at 0) -->
	<xsl:variable name="documents-in-previous-pages" select="number(/response/result[@name='response']/@start)"/>
	<!-- how many more documents are there after this current page? -->
	<xsl:variable name="more-documents" select="$documents-in-all-pages - $documents-in-previous-pages - $documents-in-current-page"/>
	<xsl:variable name="collection-id">
		<!--
		 Compute the URI of the current page; this is the IIIF "id" of the Collection document.
		 NB this URI is supposed to match the request URI generated by PROV's query builder form, 
		 but since this XSLT is provided with the URL parameters in no particular order, and has no 
		 access to the actual query URL which was used in its invocation, we will generate the URL with 
		 the parameters sorted into a canonical order: all the control parameters first (i.e. all except q), 
		 in name order, followed by the q parameter
		-->
		<xsl:value-of select="$base-uri"/>
		<xsl:apply-templates mode="encode-parameter" select="$parameters[@name != 'q']">
			<xsl:sort select="@name" order="ascending"/>
		</xsl:apply-templates>
		<xsl:text>&amp;</xsl:text>
		<xsl:apply-templates mode="encode-parameter" select="$parameters[@name = 'q']"/>
	</xsl:variable>
	<!--
	 Compute the URI of the NEXT page; this is the IIIF "id" of the Collection document after this one.
	 NB this URI is supposed to match the request URI generated by PROV's query builder form, 
	 but since this XSLT is provided with the URL parameters in no particular order, and has no 
	 access to the actual query URL which was used in its invocation, we must generate the URL with 
	 the parameters sorted into a canonical order: all the control parameters first (i.e. all except q), 
	 in name order, followed by the q parameter
	-->
	<xsl:variable name="next-page-id">
		<xsl:value-of select="$base-uri"/>
		<xsl:variable name="control-parameters" select="$parameters[@name != 'q'][@name != 'start'] | $start-parameter"/>
		<xsl:apply-templates mode="encode-parameter" select="$control-parameters">
			<xsl:with-param name="increment-start-parameter" select="true()"/>
			<xsl:sort select="@name" order="ascending"/>
		</xsl:apply-templates>
		<xsl:text>&amp;</xsl:text>
		<xsl:apply-templates mode="encode-parameter" select="$parameters[@name = 'q']"/>
	</xsl:variable>
	
	<xsl:template mode="encode-parameter" match="*">
		<xsl:param name="increment-start-parameter" select="false()"/>
		<xsl:choose>
			<!-- if we are serializing the 'start' parameter, and incrementing it (for the 'next page' URL), and
			there are actually more documents to go in a next page, then output a new 'start' parameter
			which continues on from the end of this page -->
			<xsl:when test="$increment-start-parameter and @name='start'">
				<xsl:if test="$more-documents">
					<xsl:if test="position() &gt; 1">
						<xsl:text>&amp;</xsl:text>
					</xsl:if>
					<xsl:text>start=</xsl:text>
					<xsl:value-of select="$documents-in-previous-pages + $documents-in-current-page"/>
				</xsl:if>
			</xsl:when>
			<xsl:otherwise>
				<!-- just output the existing value of the parameter -->
				<xsl:if test="position() &gt; 1">
					<xsl:text>&amp;</xsl:text>
				</xsl:if>
				<xsl:call-template name="url-encode"><xsl:with-param name="str" select="@name"/></xsl:call-template>
				<xsl:text>=</xsl:text>
				<xsl:call-template name="url-encode"><xsl:with-param name="str" select="."/></xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- The main template renders the Solr response element as a IIIF Collection document -->
	<xsl:template match="/response">
		<xsl:text>{
	"@context": [
		"http://iiif.io/api/image/2/context.json",
		"http://iiif.io/api/presentation/3/context.json"
	],
	"id": "</xsl:text>
	<xsl:call-template name="json-string"><xsl:with-param name="string" select="$collection-id"/></xsl:call-template>
	<xsl:text>",
	"type": "Collection",
	"label": { "en": [ "Search Results" ] },
	"requiredStatement": {
		"label": { "en": [ "Attribution" ] },
		"value": { "en": [ "Public Record Office Victoria" ] }
	},</xsl:text>
	<xsl:if test="$more-documents">
		<xsl:text>
	"seeAlso": [ {
		"id": "</xsl:text><xsl:value-of select="$next-page-id"/><xsl:text>",
		"type": "Collection",
		"label": { "en": [ "</xsl:text>
		<xsl:choose>
			<xsl:when test="$more-documents = 1">
				<xsl:text>1 more item...</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$more-documents"/>
				<xsl:text> more items...</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text>" ] },
		"format": "application/ld+json",
		"profile": "http://iiif.io/api/presentation/3/context.json"
	} ],</xsl:text>
	</xsl:if><xsl:text>
	"items": [</xsl:text>
  <xsl:for-each select="result/doc[str[@name='iiif-manifest']]"><!-- only "doc" (search result documents) elements which have a "iiif-manifest" field can appear in the collection -->
  	<xsl:if test="position() &gt; 1">, </xsl:if><xsl:text>
		{
			"id": "</xsl:text><xsl:value-of select="str[@name='iiif-manifest']"/><xsl:text>",
			"type": "Manifest",
			"label": { "en": [ "</xsl:text><xsl:call-template name="json-string"><xsl:with-param name="string" select="str[@name='title']"/></xsl:call-template><xsl:text>" ] },
			"summary": { "en": [ "</xsl:text>
			<xsl:call-template name="json-string">
				<xsl:with-param name="allow-markup" select="true()"/>
				<xsl:with-param name="string" select="str[@name='presentation_text']"/>
			</xsl:call-template>
			<xsl:text>" ] },
			"homepage": [
				{
					"id": "https://prov.vic.gov.au/archive/</xsl:text><xsl:value-of select="str[@name='identifier.PID.id']"/><xsl:text>",
					"type": "Text",
					"label": { "en": [ "catalogue page" ] },
					"format": "text/html"
				}
			],
			"metadata": {
</xsl:text>
				<!-- generate "metadata" properties from the fields listed -->
				<xsl:apply-templates mode="metadata" select="*[@name='jurisdictional_coverage']"/>
				<xsl:apply-templates mode="metadata" select="*[@name='location']"/>
				<xsl:apply-templates mode="metadata" select="*[@name='start_dt'][. != '1753-01-01T00:00:00Z']"/>
				<xsl:apply-templates mode="metadata" select="*[@name='end_dt'][. != '3000-12-31T00:00:00Z']"/>
				<xsl:text>
				"Series": { "en": [</xsl:text>
						<!-- TODO check: can a record really be part of multiple series? this is implied by the multi-valued nature of the is_part_of_series field -->
						<!-- find a record which belongs to multiple series, and check that this code works -->
						<xsl:call-template name="render-series-list">
							<xsl:with-param name="series-numbers" select="arr[@name='is_part_of_series.id']/str"/>
							<xsl:with-param name="series-titles" select="arr[@name='is_part_of_series.title']/str"/>
						</xsl:call-template>
<xsl:text>
				] }
			},
			"thumbnail": [
				{
					"id": "</xsl:text><xsl:value-of select="str[@name='iiif-thumbnail']"/><xsl:text>",
					"type": "Image",
					"format": "image/jpeg",
					"service": [{
						"id": "</xsl:text><xsl:value-of select="substring-before(str[@name='iiif-thumbnail'], '/full/!200,200/0/default.jpg')"/><xsl:text>",
						"type": "ImageService2",
						"profile": "http://iiif.io/api/image/2/level2.json"
					}]
				}
			]
		}</xsl:text>
	</xsl:for-each>
<xsl:text>
	]
}
</xsl:text>
	</xsl:template>
	
	<!-- Prepare a string for output as a IIIF property value -->
	<!-- Some IIIF string properties are allowed to contain HTML markup, but others are not. -->
	<!-- A property value which does contain markup must have a root element -->
	<xsl:template name="json-string">
		<xsl:param name="string"/>
		<xsl:param name="allow-markup" select="false()"/>
		<xsl:variable name="markup-purged-string">
			<xsl:call-template name="purge-markup">
				<xsl:with-param name="string" select="$string"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="markup-processed-string">
			<xsl:choose>
				<xsl:when test="$allow-markup">
					<!-- a property which allows markup must have a root element if it contains markup -->
					<xsl:choose>
						<xsl:when test="$markup-purged-string = $string"><!-- string contains no markup -->
							<xsl:value-of select="$string"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="concat('&lt;span&gt;', $string, '&lt;/span&gt;')"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:otherwise>
					<!-- markup not allowed -->
					<xsl:value-of select="$markup-purged-string"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:call-template name="escape">
			<xsl:with-param name="string">
				<xsl:call-template name="escape">
					<xsl:with-param name="string" select="normalize-space($markup-processed-string)"/>
					<xsl:with-param name="char" select=" '\' "/>
				</xsl:call-template>
			</xsl:with-param>
			<xsl:with-param name="char" select=" '&quot;' "/>
		</xsl:call-template>
	</xsl:template>
	
	<!-- a list of elements to look out for in metadata fields; they may need to be removed -->
	<xsl:variable name="elements" select="document('')/*/dummy:elements/*"/>
	<dummy:elements>
		<i/>
		<em/>
	</dummy:elements>
	<xsl:template name="purge-markup">
		<xsl:param name="string"/>
		<!-- any markup in the string should be removed -->
		<xsl:call-template name="remove-elements">
			<xsl:with-param name="string" select="$string"/>
			<xsl:with-param name="elements" select="$elements"/>
		</xsl:call-template>
	</xsl:template>
	
	<!-- a template to purge elements from a string -->
	<xsl:template name="remove-elements">
		<xsl:param name="string"/>
		<xsl:param name="elements"/>
		<xsl:choose>
			<xsl:when test="count($elements) = 0">
				<!-- no more elements to purge -->
				<xsl:value-of select="$string"/>
			</xsl:when>
			<xsl:otherwise>
				<!-- take the first element from the list, construct start and end tags, purge
				them from the string, and recurse to process the remaining elements in the list --> 
				<xsl:variable name="first-element" select="$elements[1]"/>
				<xsl:variable name="start-tag" select="concat('&lt;', local-name($first-element), '&gt;')"/>
				<xsl:variable name="end-tag" select="concat('&lt;/', local-name($first-element), '&gt;')"/>
				<xsl:call-template name="remove-elements">
					<xsl:with-param name="elements" select="$elements[position() &gt; 1]"/>
					<xsl:with-param name="string">
						<xsl:call-template name="remove-substring">
							<xsl:with-param name="substring" select="$start-tag"/>
							<xsl:with-param name="string">
								<xsl:call-template name="remove-substring">
									<xsl:with-param name="substring" select="$end-tag"/>
									<xsl:with-param name="string" select="$string"/>
								</xsl:call-template>
							</xsl:with-param>
						</xsl:call-template>
					</xsl:with-param>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- remove every occurrence of substring from string -->
	<xsl:template name="remove-substring">
		<xsl:param name="string"/>
		<xsl:param name="substring"/>
		<xsl:choose>
			<xsl:when test="contains($string, $substring)">
				<xsl:value-of select="substring-before($string, $substring)"/>
				<xsl:call-template name="remove-substring">
					<xsl:with-param name="string" select="substring-after($string, $substring)"/>
					<xsl:with-param name="substring" select="$substring"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$string"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="render-series-list">
		<xsl:param name="series-numbers"/>
		<xsl:param name="series-titles"/>
		<xsl:text>
					"</xsl:text><xsl:call-template name="json-string">
			<xsl:with-param name="string" select="$series-titles[1]"/>
		</xsl:call-template> (<xsl:call-template name="json-string">
			<xsl:with-param name= "string" select="$series-numbers[1]"/>
		</xsl:call-template><xsl:text>)"</xsl:text>
		<xsl:if test="$series-numbers[2]">
			<xsl:text>, </xsl:text>
			<xsl:call-template name="render-series-list">
				<xsl:with-param name="series-numbers" select="series-numbers[position() &gt; 1]"/>
				<xsl:with-param name="series-titles" select="series-titles[position() &gt; 1]"/>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>
	<!-- render a string as a JSON string, by normalizing white space and escaping quotes and backslashes -->
	<xsl:template name="escape">
		<xsl:param name="string"/>
		<xsl:param name="char"/>
		<xsl:choose>
			<xsl:when test="contains($string, $char)">
				<xsl:value-of select="concat(substring-before($string, $char), '\', $char)"/>
				<xsl:call-template name="escape">
					<xsl:with-param name="string" select="substring-after($string, $char)"/>
					<xsl:with-param name="char" select="$char"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$string"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<!-- render a solr field as an entry in the IIIF "metadata" object -->
	<xsl:template match="doc/*[@name]" mode="metadata">
		<xsl:text>				"</xsl:text><xsl:apply-templates select="." mode="metadata-label"/><xsl:text>": { "en": [</xsl:text>
		<xsl:for-each select="descendant-or-self::*[not(*)]"><!-- leaf elements of this field are individual values -->
			<xsl:if test="position() &gt; 1">
				<xsl:text>, </xsl:text>
			</xsl:if>
			<xsl:text>"</xsl:text><xsl:call-template name="json-string">
				<xsl:with-param name="allow-markup" select="true()"/>
				<xsl:with-param name="string">
					<xsl:apply-templates mode="metadata-value" select="."/>
				</xsl:with-param>
			</xsl:call-template><xsl:text>"</xsl:text>
		</xsl:for-each>
		<xsl:text>] } ,
</xsl:text>
	</xsl:template>
	<!-- labels for Solr fields where they should appear as entries in the IIIF "metadata" object -->
	
	<!-- by default, capitalise the initial letter of the first word, and replace all underscores with space  -->
	<xsl:template mode="metadata-label" match="*">
		<xsl:value-of select="
			concat(
				translate(
					substring(@name, 1, 1),
					'abcdefghijklmnopqrstuvwxyz', 
					'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
				),
				translate(
					substring(@name, 2),
					'_',
					' '
				)
			)
		"/>
	</xsl:template>
	<xsl:template mode="metadata-label" match="*[@name='start_dt']">Start date</xsl:template>
	<xsl:template mode="metadata-label" match="*[@name='end_dt']">End date</xsl:template>
	<!-- by default, Solr field values are expressed as a metadata property value without any change -->
	<!-- for dates, trim off the time component -->
	<xsl:template mode="metadata-value" match="*[@name='start_dt' or @name='end_dt'][contains(., 'T')]">
		<xsl:value-of select="substring-before(., 'T')"/>
	</xsl:template>
	
  <!-- ISO-8859-1 based URL-encoding demo
       Written by Mike J. Brown, mike@skew.org.
       Updated 2015-10-24 (to update the license).

       License: CC0 <https://creativecommons.org/publicdomain/zero/1.0/deed.en>

       Also see http://skew.org/xml/misc/URI-i18n/ for a discussion of
       non-ASCII characters in URIs.
  -->

  <!-- The string to URL-encode.
       Note: By "iso-string" we mean a Unicode string where all
       the characters happen to fall in the ASCII and ISO-8859-1
       ranges (32-126 and 160-255) -->

  <!-- Characters we'll support.
       We could add control chars 0-31 and 127-159, but we won't. -->
  <xsl:variable name="ascii"> !"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~</xsl:variable>
  <xsl:variable name="latin1">&#160;&#161;&#162;&#163;&#164;&#165;&#166;&#167;&#168;&#169;&#170;&#171;&#172;&#173;&#174;&#175;&#176;&#177;&#178;&#179;&#180;&#181;&#182;&#183;&#184;&#185;&#186;&#187;&#188;&#189;&#190;&#191;&#192;&#193;&#194;&#195;&#196;&#197;&#198;&#199;&#200;&#201;&#202;&#203;&#204;&#205;&#206;&#207;&#208;&#209;&#210;&#211;&#212;&#213;&#214;&#215;&#216;&#217;&#218;&#219;&#220;&#221;&#222;&#223;&#224;&#225;&#226;&#227;&#228;&#229;&#230;&#231;&#232;&#233;&#234;&#235;&#236;&#237;&#238;&#239;&#240;&#241;&#242;&#243;&#244;&#245;&#246;&#247;&#248;&#249;&#250;&#251;&#252;&#253;&#254;&#255;</xsl:variable>

  <!-- Characters that usually don't need to be escaped -->
  <xsl:variable name="safe">!'()*-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~</xsl:variable>

  <xsl:variable name="hex" >0123456789ABCDEF</xsl:variable>

  <xsl:template name="url-encode">
    <xsl:param name="str"/>   
    <xsl:if test="$str">
      <xsl:variable name="first-char" select="substring($str,1,1)"/>
      <xsl:choose>
        <xsl:when test="contains($safe,$first-char)">
          <xsl:value-of select="$first-char"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="codepoint">
            <xsl:choose>
              <xsl:when test="contains($ascii,$first-char)">
                <xsl:value-of select="string-length(substring-before($ascii,$first-char)) + 32"/>
              </xsl:when>
              <xsl:when test="contains($latin1,$first-char)">
                <xsl:value-of select="string-length(substring-before($latin1,$first-char)) + 160"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:message terminate="no">Warning: string contains a character that is out of range! Substituting "?".</xsl:message>
                <xsl:text>63</xsl:text>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
        <xsl:variable name="hex-digit1" select="substring($hex,floor($codepoint div 16) + 1,1)"/>
        <xsl:variable name="hex-digit2" select="substring($hex,$codepoint mod 16 + 1,1)"/>
        <xsl:value-of select="concat('%',$hex-digit1,$hex-digit2)"/>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:if test="string-length($str) &gt; 1">
        <xsl:call-template name="url-encode">
          <xsl:with-param name="str" select="substring($str,2)"/>
        </xsl:call-template>
      </xsl:if>
    </xsl:if>
  </xsl:template>	
	
</xsl:stylesheet>